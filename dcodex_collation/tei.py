import sys
from .models import *
import xml.etree.ElementTree as ET
from typing import Optional
from slugify import slugify

ATEXT_SIGLUM = "AText"

def state_slug(state):
    slug = slugify(str(state), lowercase=False, separator='_')
    return f"{state.id}-{slug}"

def add_transition(transcriptional_relations, transition, rate_system, transcriptional_options):
    if rate_system:
        rate = rate_system.get_transition_rate(transition=transition)
        ana = f"#{rate}"
        
    else:
        ana = f"#{transition.transition_type_str()}"
    
    ana = ana.replace(" ", "_")
    transcriptional_options.add(ana[1:])

    return ET.SubElement(
        transcriptional_relations, 
        'relation',
        active=state_slug(transition.start_state), # start reading n
        passive=state_slug(transition.end_state),
        ana=ana, # the rate, https://www.tei-c.org/release/doc/tei-p5-doc/en/html/ref-att.global.analytic.html
        type=transition.transition_type_str(),
    )


def write_tei(
    family, 
    verses, 
    witnesses=None, 
    file=None, 
    allow_ignore=True, 
    atext=True,
    max_readings:int=0,
    rate_system:Optional[RateSystem]=None,
    multistate:bool=False,
    atext_certainty_degree:int=5,
):
    witnesses = witnesses or family.manuscripts()

    root = ET.Element('TEI', xmlns="http://www.tei-c.org/ns/1.0")
    teiHeader = ET.SubElement(root, 'teiHeader')
    fileDesc = ET.SubElement(teiHeader, 'fileDesc')
    titleStmt = ET.SubElement(fileDesc, 'titleStmt')
    respStmt = ET.SubElement(titleStmt, 'respStmt')
    resp = ET.SubElement(respStmt, 'resp')
    resp.text = "Generated by dcodex."

    publicationStmt = ET.SubElement(fileDesc, 'publicationStmt')
    ET.SubElement(publicationStmt, 'p').text = "Generated by dcodex."

    sourceDesc = ET.SubElement(fileDesc, 'sourceDesc')
    ET.SubElement(sourceDesc, 'p').text = "Generated by dcodex."

    listWit = ET.SubElement(sourceDesc, 'listWit')

    text_element = ET.SubElement(root, 'text')
    interp_intrinsic = ET.SubElement(text_element, 'interpGrp', type="intrinsic")
    interp = ET.SubElement(interp_intrinsic, 'interp', attrib={"xml:id":"AText"})
    certainty = ET.SubElement(interp, 'certainty', degree=str(atext_certainty_degree))
    interp_transcriptional = ET.SubElement(text_element, 'interpGrp', type="transcriptional")
    transcriptional_options = set()

    body = ET.SubElement(text_element, 'body')

    all_sigla = set()
    
    for verse in verses:
        alignment = Alignment.objects.filter(family=family, verse=verse).first()
        if not alignment:
            continue
    
        verse_slug = slugify(verse.url_ref(), lowercase=False, separator='_')
        for column in alignment.column_set.all():
            if column.only_punctuation():
                continue

            states = column.states(allow_ignore=allow_ignore)
            if multistate and states.count() < 2:
                continue

            location = str(column)
            column_xmlid = f"C{column.id}__{verse_slug}__{column.order}"
            app = ET.SubElement(body, 'app', attrib={"xml:id": column_xmlid, "loc": location})
            atext_state = column.get_atext_state(allow_ignore)
            if atext_state:
                lem = ET.SubElement(app, 'lem')
                lem.text = str(atext_state)

            for state in states:
                reading_text = state.str_at(column)
                
                cells = column.cells_with_state(state, allow_ignore=allow_ignore)
                sigla = cells.values_list("row__transcription__manuscript__siglum", flat=True)
                witnesses_str = " ".join(sigla)
                if atext and state == column.atext:
                    witnesses_str = f"{ATEXT_SIGLUM} {witnesses_str}"
                    all_sigla.add(ATEXT_SIGLUM)

                rdg = ET.SubElement(app, 'rdg', wit=witnesses_str, n=state_slug(state))
                rdg.text = reading_text

                all_sigla.update(sigla)

            
            note = ET.Element('note')
            if atext_state:
                intrinsic_relations = ET.SubElement(note, 'listRelation', type="intrinsic")
                if column.atext_notes:
                    ET.SubElement(intrinsic_relations, 'desc').text = column.atext_notes
                    
                for state in states:
                    if state != column.atext:
                        relation = ET.SubElement(
                            intrinsic_relations, 
                            'relation',
                            active=state_slug(column.atext), # start reading n
                            passive=state_slug(state),
                            ana="#AText",
                        )
                
            # List transitions as notes with relation elements
            transitions = column.transition_set.all()
            if transitions.count() > 0:
                transcriptional_relations = ET.SubElement(note, 'listRelation', attrib={"type":"transcriptional"})
                for transition in transitions:
                    add_transition(transcriptional_relations, transition, rate_system, transcriptional_options)
                    add_transition(transcriptional_relations, transition.create_inverse(), rate_system, transcriptional_options)

            if len(note):
                app.append(note)

    included_mss = family.manuscripts().filter(siglum__in=all_sigla)
    if atext:
        witness = ET.SubElement(listWit, 'witness', n=ATEXT_SIGLUM)

    for ms in included_mss:
        witness = ET.SubElement(listWit, 'witness', n=ms.siglum)

        origin_date_earliest, origin_date_latest = getattr(ms, 'origin_date_earliest', None), getattr(ms, 'origin_date_latest', None)

        if origin_date_earliest is not None:
            if origin_date_earliest == origin_date_latest:
                ET.SubElement(witness, 'origDate', when=str(origin_date_earliest))
            else:
                ET.SubElement(witness, 'origDate', notBefore=str(origin_date_earliest), notAfter=str(origin_date_latest))
        
    for ana in transcriptional_options:
        ET.SubElement(interp_transcriptional, 'interp', attrib={"xml:id":ana})

    tree = ET.ElementTree(root)
    ET.indent(tree, space="\t", level=0)
    string = ET.tostring(root, encoding="utf-8")
    if file:
        file.write(string.decode("utf-8"))

    print(string.decode("utf-8"))

